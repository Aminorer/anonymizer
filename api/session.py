import uuid
import pickle
from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any
from docx import Document
import io
import logging
import threading
import time

from models import Entity, AuditLog, RGPD_CONFIG

logger = logging.getLogger(__name__)

class SessionManager:
    """
    üóÑÔ∏è Gestionnaire de sessions optimis√© pour Vercel
    
    ‚úÖ Stockage en m√©moire uniquement (pas Redis)
    ‚úÖ Auto-nettoyage des sessions expir√©es
    ‚úÖ Conformit√© RGPD stricte (suppression imm√©diate)
    ‚úÖ Thread-safe pour environnement serverless
    """
    
    def __init__(self):
        # Stockage en m√©moire (thread-safe)
        self._sessions: Dict[str, Dict[str, Any]] = {}
        self._lock = threading.RLock()
        
        # Configuration RGPD
        self.session_expire_minutes = RGPD_CONFIG["session_max_duration_minutes"]
        self.auto_deletion = RGPD_CONFIG["auto_deletion"]
        
        # D√©marrer le nettoyage automatique
        self._start_cleanup_thread()
        
        logger.info("‚úÖ SessionManager initialis√© (m√©moire uniquement, RGPD strict)")
    
    def create_session(self, document: Document, original_text: str, 
                      entities: List[Entity], filename: str) -> str:
        """
        üÜï Cr√©e une nouvelle session temporaire en m√©moire
        
        Conformit√© RGPD :
        - Dur√©e de vie limit√©e (15 minutes)
        - Suppression automatique garantie
        - Aucune persistance sur disque
        """
        session_id = str(uuid.uuid4())
        
        # S√©rialiser le document DOCX en bytes
        doc_stream = io.BytesIO()
        document.save(doc_stream)
        doc_bytes = doc_stream.getvalue()
        doc_stream.close()
        
        # Pr√©parer les donn√©es de session
        now = datetime.now()
        expires_at = now + timedelta(minutes=self.session_expire_minutes)
        
        session_data = {
            'session_id': session_id,
            'filename': filename,
            'original_text': original_text,
            'entities': [entity.__dict__ if hasattr(entity, '__dict__') else entity for entity in entities],
            'document_bytes': doc_bytes,
            'created_at': now.isoformat(),
            'expires_at': expires_at.isoformat(),
            'accessed_at': now.isoformat(),
            'rgpd_compliant': True,
            'processing_location': 'vercel_serverless'
        }
        
        # Stockage thread-safe
        with self._lock:
            self._sessions[session_id] = session_data
        
        logger.info(f"‚úÖ Session cr√©√©e: {session_id} (expire: {expires_at.strftime('%H:%M:%S')})")
        return session_id
    
    def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """
        üìñ R√©cup√®re les donn√©es d'une session avec v√©rification d'expiration
        """
        with self._lock:
            session_data = self._sessions.get(session_id)
            
            if not session_data:
                logger.warning(f"‚ùå Session introuvable: {session_id}")
                return None
            
            # V√©rifier l'expiration
            expires_at = datetime.fromisoformat(session_data['expires_at'])
            if datetime.now() > expires_at:
                logger.info(f"‚è∞ Session expir√©e: {session_id}")
                # Suppression imm√©diate (conformit√© RGPD)
                del self._sessions[session_id]
                return None
            
            # Mettre √† jour le dernier acc√®s
            session_data['accessed_at'] = datetime.now().isoformat()
            
            logger.debug(f"‚úÖ Session acc√©d√©e: {session_id}")
            return session_data
    
    def update_session_entities(self, session_id: str, entities: List[Entity]) -> bool:
        """
        üîÑ Met √† jour les entit√©s d'une session
        """
        with self._lock:
            session_data = self._sessions.get(session_id)
            if not session_data:
                logger.warning(f"‚ùå Session introuvable pour mise √† jour: {session_id}")
                return False
            
            # V√©rifier l'expiration
            expires_at = datetime.fromisoformat(session_data['expires_at'])
            if datetime.now() > expires_at:
                logger.info(f"‚è∞ Session expir√©e lors de la mise √† jour: {session_id}")
                del self._sessions[session_id]
                return False
            
            # Mettre √† jour les entit√©s
            session_data['entities'] = [entity.__dict__ if hasattr(entity, '__dict__') else entity for entity in entities]
            session_data['updated_at'] = datetime.now().isoformat()
            session_data['accessed_at'] = datetime.now().isoformat()
            
            logger.info(f"‚úÖ Entit√©s mises √† jour: {session_id} ({len(entities)} entit√©s)")
            return True
    
    def get_document_from_session(self, session_id: str) -> Optional[Document]:
        """
        üìÑ R√©cup√®re le document DOCX d'une session
        """
        session_data = self.get_session(session_id)
        if not session_data:
            return None
        
        try:
            doc_bytes = session_data.get('document_bytes')
            if doc_bytes:
                doc_stream = io.BytesIO(doc_bytes)
                document = Document(doc_stream)
                logger.debug(f"‚úÖ Document r√©cup√©r√©: {session_id}")
                return document
        except Exception as e:
            logger.error(f"‚ùå Erreur r√©cup√©ration document {session_id}: {e}")
        
        return None
    
    def delete_session(self, session_id: str) -> bool:
        """
        üóëÔ∏è Supprime une session (conformit√© RGPD)
        
        Suppression imm√©diate et compl√®te des donn√©es
        """
        with self._lock:
            if session_id in self._sessions:
                # R√©cup√©rer les m√©tadonn√©es avant suppression
                session_data = self._sessions[session_id]
                filename = session_data.get('filename', 'unknown')
                
                # Suppression compl√®te
                del self._sessions[session_id]
                
                logger.info(f"üóëÔ∏è Session supprim√©e (RGPD): {session_id} - {filename}")
                return True
            else:
                logger.warning(f"‚ùå Session d√©j√† supprim√©e: {session_id}")
                return False
    
    def cleanup_expired_sessions(self) -> int:
        """
        üßπ Nettoie les sessions expir√©es (t√¢che de maintenance automatique)
        
        Conformit√© RGPD : suppression automatique apr√®s expiration
        """
        current_time = datetime.now()
        expired_sessions = []
        
        with self._lock:
            for session_id, session_data in list(self._sessions.items()):
                try:
                    expires_at = datetime.fromisoformat(session_data['expires_at'])
                    if current_time > expires_at:
                        expired_sessions.append(session_id)
                except Exception as e:
                    logger.error(f"‚ùå Erreur v√©rification expiration {session_id}: {e}")
                    expired_sessions.append(session_id)  # Supprimer par s√©curit√©
            
            # Supprimer toutes les sessions expir√©es
            for session_id in expired_sessions:
                if session_id in self._sessions:
                    del self._sessions[session_id]
        
        if expired_sessions:
            logger.info(f"üßπ {len(expired_sessions)} sessions expir√©es supprim√©es (RGPD)")
        
        return len(expired_sessions)
    
    def generate_audit_log(self, session_id: str, replacements: Dict[str, str]) -> Optional[AuditLog]:
        """
        üìù G√©n√®re un log d'audit RGPD pour tra√ßabilit√©
        """
        session_data = self.get_session(session_id)
        if not session_data:
            logger.warning(f"‚ùå Session introuvable pour audit: {session_id}")
            return None
        
        try:
            # Analyser les types d'entit√©s remplac√©es
            entities_data = session_data.get('entities', [])
            entities_dict = {}
            
            for entity_data in entities_data:
                if isinstance(entity_data, dict):
                    text = entity_data.get('text', '')
                    entities_dict[text] = entity_data
                elif hasattr(entity_data, 'text'):
                    entities_dict[entity_data.text] = entity_data
            
            # Cr√©er le r√©sum√© des remplacements
            replacement_summary = []
            for original, replacement in replacements.items():
                entity_info = entities_dict.get(original, {})
                
                if isinstance(entity_info, dict):
                    entity_type = entity_info.get('type', 'UNKNOWN')
                    confidence = entity_info.get('confidence', 0.0)
                    source = entity_info.get('source', 'unknown')
                else:
                    entity_type = getattr(entity_info, 'type', 'UNKNOWN')
                    confidence = getattr(entity_info, 'confidence', 0.0)
                    source = getattr(entity_info, 'source', 'unknown')
                
                replacement_summary.append({
                    "type": entity_type,
                    "method": f"{source}_validated_replacement",
                    "original_length": len(original),
                    "replacement": replacement,
                    "confidence": confidence,
                    "processing_mode": "regex" if source == "regex" else "ner_distilcamembert"
                })
            
            # Cr√©er le log d'audit
            audit_log = AuditLog(
                document=session_data['filename'],
                timestamp=datetime.now().isoformat(),
                entities_anonymized=len(replacements),
                replacement_summary=replacement_summary
            )
            
            logger.info(f"üìù Log d'audit g√©n√©r√©: {session_id} - {len(replacements)} entit√©s")
            return audit_log
            
        except Exception as e:
            logger.error(f"‚ùå Erreur g√©n√©ration audit log {session_id}: {e}")
            return None
    
    def get_session_stats(self) -> Dict[str, Any]:
        """
        üìä Retourne les statistiques des sessions actives
        """
        with self._lock:
            active_sessions = len(self._sessions)
            total_entities = 0
            
            # Calculer les statistiques
            for session_data in self._sessions.values():
                entities = session_data.get('entities', [])
                total_entities += len(entities)
            
            # Statistiques par source de d√©tection
            source_stats = {'regex': 0, 'ner': 0, 'manual': 0}
            type_stats = {}
            
            for session_data in self._sessions.values():
                entities = session_data.get('entities', [])
                for entity_data in entities:
                    if isinstance(entity_data, dict):
                        source = entity_data.get('source', 'unknown')
                        entity_type = entity_data.get('type', 'UNKNOWN')
                    else:
                        source = getattr(entity_data, 'source', 'unknown')
                        entity_type = getattr(entity_data, 'type', 'UNKNOWN')
                    
                    # Stats par source
                    if source in source_stats:
                        source_stats[source] += 1
                    
                    # Stats par type
                    type_stats[entity_type] = type_stats.get(entity_type, 0) + 1
        
        return {
            "active_sessions": active_sessions,
            "total_entities": total_entities,
            "memory_usage": "in_memory_only",
            "session_backend": "memory",
            "rgpd_compliant": True,
            "auto_cleanup_enabled": True,
            "session_max_duration_minutes": self.session_expire_minutes,
            "detection_sources": source_stats,
            "entity_types_distribution": type_stats
        }
    
    def _start_cleanup_thread(self):
        """
        üßπ D√©marre le thread de nettoyage automatique
        
        Nettoie les sessions expir√©es toutes les 5 minutes
        """
        def cleanup_worker():
            while True:
                try:
                    self.cleanup_expired_sessions()
                    time.sleep(300)  # 5 minutes
                except Exception as e:
                    logger.error(f"‚ùå Erreur thread cleanup: {e}")
                    time.sleep(60)  # Retry apr√®s 1 minute en cas d'erreur
        
        cleanup_thread = threading.Thread(target=cleanup_worker, daemon=True)
        cleanup_thread.start()
        logger.info("üßπ Thread de nettoyage automatique d√©marr√© (toutes les 5 minutes)")
    
    def get_memory_usage(self) -> Dict[str, Any]:
        """
        üìä Retourne l'utilisation m√©moire des sessions
        """
        with self._lock:
            total_sessions = len(self._sessions)
            total_documents_size = 0
            total_text_size = 0
            total_entities = 0
            
            for session_data in self._sessions.values():
                # Taille des documents
                doc_bytes = session_data.get('document_bytes', b'')
                total_documents_size += len(doc_bytes)
                
                # Taille du texte
                original_text = session_data.get('original_text', '')
                total_text_size += len(original_text.encode('utf-8'))
                
                # Nombre d'entit√©s
                entities = session_data.get('entities', [])
                total_entities += len(entities)
            
            return {
                "total_sessions": total_sessions,
                "total_documents_size_mb": round(total_documents_size / (1024 * 1024), 2),
                "total_text_size_kb": round(total_text_size / 1024, 2),
                "total_entities": total_entities,
                "average_entities_per_session": round(total_entities / max(total_sessions, 1), 1),
                "storage_backend": "memory_only",
                "rgpd_retention": "0_minutes"
            }
    
    def force_cleanup_all(self):
        """
        üö® Force la suppression de toutes les sessions (urgence RGPD)
        """
        with self._lock:
            session_count = len(self._sessions)
            self._sessions.clear()
            logger.warning(f"üö® NETTOYAGE FORC√â: {session_count} sessions supprim√©es")
        
        return session_count

# Instance globale pour l'application
session_manager = SessionManager()
            